var astree = require('./ast.js');
var err = require('./error.js');

const ARGTYPES = {
	'percent': {
		code: 0,
		typestr: 'percent'
	},
	'int': {
		code: 1,
		typestr: 'int'
	},
	'str': {
		code: 2,
		typestr: 'str'
	},
	'rstr': {
		code: 3,
		typestr: 'rstr'
	}
}

var EXPRESSIONS = {
	root: { has: {}, handle: () => { return ['', '']; } },
	rstring: {
		has: {'text': ARGTYPES.rstr},
		handle: (arg) => { return [arg.text, '']; }
	},
	h: {
		has: { 'size': ARGTYPES.percent, },
		handle: (arg) => {
			let s = arg.size.replace('%', 'vh');
			return [
				`<h1 style="font-size: ${s};">`,
				'</h1>'
			];
		}
	},
	lead: {
		has: {},
		handle: (arg) => {
			return [
				`<p class="lead">`,
				'</p>'
			]
		}
	},
	bold: {
		has: {},
		handle: () => {
			return [
				'<span style="font-weight: bold;">',
				'</span>'
			];
		}
	},
	italic: {
		has: {},
		handle: () => {
			return [
				'<span style="font-style: italic;">',
				'</span>'
			];
		}
	},
	image: {
		has: {
			'url': ARGTYPES.str,
			'width': ARGTYPES.percent,
			'height': ARGTYPES.percent
		},
		handle: (arg) => {
			let w = arg.width.replace('%', 'vh');
			let h = arg.height.replace('%', 'vw');
			return [
				`<img src=${arg.url} style="width: ${w}; height: ${h};">`,
				'</img>'
			];
		}
	},
	paragraph: {
		has: {},
		handle: () => {
			return ['<p>',Â '</p>'];
		}
	},
	size: {
		has: { 'size': ARGTYPES.percent },
		handle: (arg) => {
			let s = arg.size.replace('%', 'vh');
			return [
				`<span style="font-size: ${s}">`,
				'</span>'
			];
		}
	},
	color: {
		has: { 'c': ARGTYPES.str },
		handle: (arg) => {
			return [
				`<span style="color: ${arg.c}">`,
				'</span>'
			];
		}
	}
}

function get_argtype(arg) {
	if (arg.match(/^[0-9]*\%$/)) {
		return ARGTYPES.percent;
	} else if (arg.match(/^[0-9]*$/)) {
		return ARGTYPES.int;
	} else if (
		arg.match(/^\'.*\'$/)
		|| arg.match(/^\".*\"$/)
	) {
		return ARGTYPES.str;
	} else {
		return ARGTYPES.rstr;
	}
}

function chk_argtypes(node) {
	// Check node argument types.
	let expr = EXPRESSIONS[node.name];
	let atype = null;
	let typestr = '';
	for (let a in node.data) {
		if (!(a in expr.has)) {
			throw new err.MarkupSyntaxError(
				'EARG',
				node.lexeme,
				`Extra argument '${a}' in tag '${node.name}'.`
			);
		}
		atype = get_argtype(node.data[a]);
		if (expr.has[a].code != atype.code) {
			throw new err.MarkupSyntaxError(
				'ETYPE',
				node.lexeme,
				`Invalid type '${atype.typestr}' for '${a}'. ` +
				`Expected '${expr.has[a].typestr}'.`
			);
		}
	}
	for (let a in expr.has) {
		if (!node.data || !(a in node.data)) {
			throw new err.MarkupSyntaxError(
				'EARG',
				node.lexeme,
				`Missing argument '${a}' in tag '${node.name}'.`
			);
		}
	}
}

function eval_node(node) {
	let buf = '';
	let expr = null;
	let out = null;

	if (!(node.name in EXPRESSIONS)) {
		throw new err.MarkupSyntaxError(
			'ETAG',
			node.lexeme,
			node.name
		);
	}
	expr = EXPRESSIONS[node.name];
	chk_argtypes(node);

	out = expr.handle(node.data);
	buf += out[0];
	for (let n of node.nodes) {
		buf += eval_node(n);
	}
	buf += out[1];
	return buf;
}

module.exports.eval = function(ast) {
	return eval_node(ast.nodes);
}
