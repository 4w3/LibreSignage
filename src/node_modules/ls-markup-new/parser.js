var lexeme = require('./lexeme.js');
var lexer = require('./lexer.js');
var tokens = require('./tokens.js');
var mutil = require('./mutil.js');
var util = require('util');

var RULES = {
	'BRACK_OPEN': {
		opt: false,
		cnt: 1,
		exp: {
			'0': {
				match: true,
				opt: true,
				cnt: Infinity,
				exp: ['WHITESPACE']
			},
			'1': {
				match: true,
				opt: true,
				cnt: 1,
				exp: ['BRACK_SLASH'],
				id: 'slash'
			},
			'2': {
				match: true,
				opt: false,
				cnt: 1,
				exp: ['TAGNAME'],
				id: 'tag'
			},
			'3': {
				match: true,
				opt: true,
				cnt: Infinity,
				exp: ['WHITESPACE']
			},
			'5': {
				match: false,
				opt: true,
				cnt: Infinity,
				id: 'var',
				makearray: true,
				exp: {
					'1': {
						match: true,
						opt: false,
						cnt: 1,
						exp: ['VARNAME'],
						id: 'name'
					},
					'2': {
						match: true,
						opt: true,
						cnt: Infinity,
						exp: ['WHITESPACE']
					},
					'3': {
						match: true,
						opt: false,
						cnt: 1,
						exp: ['OP_ASSIGN']
					},
					'4': {
						match: true,
						opt: true,
						cnt: Infinity,
						exp: ['WHITESPACE']
					},
					'5': {
						match: true,
						opt: false,
						cnt: 1,
						exp: ['LITERAL'],
						id: 'value'
					},
					'6': {
						match: true,
						opt: true,
						cnt: Infinity,
						exp: ['WHITESPACE']
					}
				}
			},
			'6': {
				match: true,
				opt: false,
				cnt: 1,
				exp: ['BRACK_CLOSE']
			}
		},
		valid: (ast, self, matched) => {
			let data = [];
			if ('slash' in matched) {
				if ('var' in matched) {
					throw new Error(
						"Can't have parameters in a closing tag."
					);
				}
				ast.close_node(matched.tag.raw);
			} else {
				ast.open_node(matched.tag.raw);
			}
			if ('var' in matched) {
				for (let v of matched['var']) {
					data[v.name.raw] = v.value.raw;
				}
				ast.set_data(data);
			}
		}
	},
	'BRACK_CLOSE': {
		expect: {},
		valid: () => { throw new Error('Unexpected SEP_BRACK_CLOSE.'); },
		invalid: () => {}
	},
	'LITERAL': {
		expect: {},
		valid: (ast, self, matched) => {
			ast.open_node('string');
			ast.set_data(self.raw);
			ast.close_node('string');
		}
	},
	'WHITESPACE': {
		expect: {},
		valid: (ast, self, matched) => {
			ast.open_node('string');
			ast.set_data(self.raw);
			ast.close_node('string');
		}
	}
}

module.exports.AST = class AST {
	constructor() {
		this.nodes = [
			{
				'name': 'root',
				'nodes': [],
				'data': null,
				'parent': null
			}
		];
		this.cnode = this.nodes[0];
	}

	open_node(name) {
		let tmp = {
			'name': name,
			'nodes': [],
			'data': null,
			'parent': this.cnode
		};
		this.cnode.nodes.push(tmp);
		this.cnode = tmp;
	}

	close_node(name) {
		if (!this.cnode.parent) {
			throw new Error("AST: Can't close the root node.");
		}
		if (this.cnode.name != name) {
			throw new Error(
				`AST: Expected to close node '${this.cnode.name}' ` +
				`but attempted to close node '${name}' instead.`
			);
		}
		this.cnode = this.cnode.parent;
	}

	set_data(data) {
		this.cnode.data = data;
	}

	dump() {
		console.log(util.inspect(this.nodes, {'depth': null}));
	}
}

function pmatch_rule(rule, lexemes, at, matched) {
	let new_i = 0;
	let i = at;
	let m = {};

	for (let j in rule.exp) {
		if (!rule.exp[j].match) {
			// Process subrule.
			for (let k = 0; k < rule.exp[j].cnt; k++) {
				m = {};
				new_i = pmatch_rule(rule.exp[j], lexemes, i, m);
				if (new_i == i) {
					// Optional subrule didn't match.
					break;
				} else {
					i = new_i;
				}
				if (rule.exp[j].id) {
					if (rule.exp[j].makearray) {
						if (!matched[rule.exp[j].id]) {
							matched[rule.exp[j].id] = [];
						}
						matched[rule.exp[j].id].push(m);
					} else {
						matched[rule.exp[j].id] = m;
					}
				}
			}
		} else {
			for (let k = 0; k < rule.exp[j].cnt; k++) {
				if (i > lexemes.length - 1) {
					// Token stream ends unexpectedly.
					if (rule.exp[j].opt) {
						return at;
					} else {
						throw new Error(
							`Unexpected End Of Token Stream. ` +
							`Expected '${rule.exp[j].exp[0]}'.`
						)
					}
				}
				if (rule.exp[j].exp[0] == lexemes[i].type) {
					if (rule.exp[j].id) {
						matched[rule.exp[j].id] = lexemes[i];
					}
					i++;
				} else if (
					rule.exp[j].opt
					|| rule.exp[j].cnt === Infinity
				) {
					/*
					*  Optional token or a token without a specific
					*  count -> continue to the next one.
					*/
					break;
				} else if (rule.opt && !rule.exp[j].opt) {
					return at;
				} else {
					// Token doesn't match. Throw an error.
					throw new Error(
						`Unexpected ${lexemes[i].type}, ` +
						`expected ${rule.exp[j].exp[0]}.`
					);
				}
			}
		}
	}
	return i;
}

module.exports.parse = function(str) {
	let lexemes = lexer.process(str);
	let buf = '';
	let self = null;
	let rule = null;
	let matched = {};
	let ast = new module.exports.AST();

	lexeme.dump_lexemes(lexemes);

	let i = 0;
	while (i < lexemes.length) {
		self = lexemes[i];
		rule = RULES[lexemes[i].type];
		i++;

		i = pmatch_rule(rule, lexemes, i, matched);
		rule.valid(ast, self, matched);

		matched = {};
		self = null;
	}
	if (ast.cnode.name != 'root') {
		throw new Error(
			`AST: Unexpected end of token stream. ` +
			`Node '${ast.cnode.name}' left open.`
		)
	}
	ast.dump();
	return buf;
}
