var lexeme = require('./lexeme.js');
var lexer = require('./lexer.js');
var tokens = require('./tokens.js');
var mutil = require('./mutil.js');
var util = require('util');

var RULES = {
	'BRACK_OPEN': {
		expect: {
			'0': {
				opt: true,
				cnt: Infinity,
				tok: ['WHITESPACE']
			},
			'1': {
				opt: true,
				cnt: 1,
				tok: ['BRACK_SLASH'],
				id: 'slash'
			},
			'2': {
				opt: false,
				cnt: 1,
				tok: ['TAGNAME'],
				id: 'tag'
			},
			'3': {
				opt: true,
				cnt: Infinity,
				tok: ['WHITESPACE']
			},
			'4': {
				opt: false,
				cnt: 1,
				tok: ['BRACK_CLOSE']
			}
		},
		valid: (buf_write, self, matched) => {
			if ('slash' in matched) {
				buf_write(`</${matched['tag'].raw}>`);
			} else {
				buf_write(`<${matched['tag'].raw}>`);
			}
		}
	},
	'BRACK_CLOSE': {
		expect: {},
		valid: () => { throw new Error('Unexpected SEP_BRACK_CLOSE.'); },
		invalid: () => {}
	},
	'LITERAL': {
		expect: {},
		valid: (buf_write, self, matched) => {
			buf_write(self.raw);
		}
	},
	'WHITESPACE': {
		expect: {},
		valid: (buf_write, self, matched) => {
			buf_write(self.raw);
		}
	}
}

module.exports.parse = function(str) {
	let lexemes = lexer.process(str);
	let buf = '';
	let r = null;
	let self = null;
	let matched = [];
	let handler_buf_write = (s) => { buf += s; }

	lexeme.dump_lexemes(lexemes);

	let i = 0;
	while (i < lexemes.length) {
		if (!r) {
			r = RULES[lexemes[i].type];
			self = lexemes[i];
			i++;
			continue;
		}
		for (let j in r.expect) {
			for (let k = 0; k < r.expect[j].cnt; k++) {
				if (r.expect[j]['tok'][0] == lexemes[i].type) {
					// Token matches.
					if (r.expect[j]['id']) {
						matched[r.expect[j]['id']] = lexemes[i];
					}
					i++;
				} else if (
					r.expect[j]['opt']
					|| r.expect[j]['cnt'] === Infinity
				) {
					/*
					*  Optional token or a token without a specific
					*  count -> Next token.
					*/
					break;
				} else {
					// Token doesn't match. Throw an error.
					throw new Error(
						`Unexpected ${lexemes[i].type}, ` +
						`expected ${r.expect[j]['tok'][0]}.`
					);
				}
			}
		}
		r.valid(handler_buf_write, self, matched);

		r = null;
		self = null;
		matched = [];
	}
	return buf;
}
