/*
*  Token definitions for the LibreSignage markup transpiler.
*/

var lexeme = require('./lexeme.js');
var lpost = require('./lexer_post.js');

/*
*  Lexer token definitions.
*/
module.exports.tokens = {
	BRACK_OPEN: {
		re: /^\[/,
		repr: '[',
		context: [ { '-1': '!BACKWARD_SLASH' } ]
	},
	BRACK_CLOSE: {
		re: /^\]/,
		repr: ']',
		context: [ { '-1': '!BACKWARD_SLASH' } ]
	},
	FORWARD_SLASH: {
		re: /^\//,
		repr: '/',
		context: [ { '-1': '!BACKWARD_SLASH' } ]
	},
	BACKWARD_SLASH: {
		re: /^\\/,
		repr: '\\',
		context: [ { '-1': '!BACKWARD_SLASH' } ]
	},
	ASSIGN: {
		re: /^=/,
		repr: '=',
		context: [
			{ '-1': 'LITERAL' },
			{ '-2': 'LITERAL', '-1': 'WHITESPACE' }
		]
	},
	WHITESPACE: {
		re: /^\s+/,
		repr: '(whitespace)'
	},
	LITERAL: {
		re: /^[=\[\]]?[^=\[\]\\\s]*/,
		repr: '(literal)'
	},

	// Post-processor created tokens.
	TAGNAME: {
		nomatch: true,
		repr: '(tagname)',
	},
	IDENTIFIER: {
		nomatch: true,
		repr: '(identifier)'
	}
}

/*
*  Lexer post processor functions.
*
*  Each object in this array contains a type
*  value that defines the type of the lexeme
*  the post-processor function modifies and
*  a post key that contains the function that
*  does all the work. The lexeme array and the
*  type are passed to the post-processor function
*  as arguments.
*/
module.exports.post = [
	{ // Suppress backward slashes.
		type: 'BACKWARD_SLASH',
		post: lpost.lexer_post_suppress
	},
	{ // Concatenate subsequent literals.
		type: 'LITERAL',
		post: lpost.lexer_post_cat
	},
	{ // Turn LITERALs after '[' or '[/' into TAGNAMEs.
		type: 'LITERAL',
		post: function(lexemes, type) {
			let ret = lexemes.slice();;
			for (let i = 0; i < ret.length; i++) {
				if (ret[i].type == 'BRACK_OPEN') {
					if (
						ret.length - 1 >= i + 1
						&& ret[i + 1].type == 'LITERAL'
					) {
						ret[i + 1].ch_type('TAGNAME');
					} else if (
						ret.length - 1 >= i + 2
						&& ret[i + 1].type == 'FORWARD_SLASH'
						&& ret[i + 2].type == 'LITERAL'
					) {
						ret[i + 2].ch_type('TAGNAME');
					}
				}
			}
			return ret;
		}
	},
	{ // Turn LITERALs followed by an assignment into IDENTIFIERs.
		type: 'LITERAL',
		post: function(lexemes, type) {
			let ret = lexemes.slice();
			for (let i = 0; i < ret.length; i++) {
				if (
					ret[i].type == type
					&& (
						(
							ret.length - 1 >= i + 1
							&& ret[i + 1].type == 'ASSIGN'
						)
						|| (
							ret.length - 1 >= i + 2
							&& ret[i + 1].type == 'WHITESPACE'
							&& ret[i + 2].type == 'ASSIGN'
						)
					)
				) {
					ret[i].ch_type('IDENTIFIER');
				}
			}
			return ret;
		}
	}
]
