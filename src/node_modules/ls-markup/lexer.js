/*
*  A lexer implementation for the LibreSignage markup parser.
*  The token definitions are in tokens.js.
*/

var lexeme = require('./lexeme.js');
var tokens = require('./tokens.js');
var util = require('util');

function tok_match(tok, str, index) {
	return str.substring(index).match(tok.re);
}

function tok_context(tok, lexemes, index) {
	let ret = null;
	if (!tok.context) { return -1; }
	for (let mcase in tok.context) {
		for (let i in tok.context[mcase]) {
			let tmp = index + parseInt(i, 10);
			if (tmp < 0) { break; }
			if (lexemes[tmp].type != tok.context[mcase][i]) { break; }
			ret = mcase;
		}
		if (ret) { return ret; }
	}
	return null;
}

module.exports.process = function(str) {
	let ret = [];
	let ln_pos = 0;
	let ln_num = 0;
	let l = null;
	let l_index = 0;
	let tok = null;
	let match = null;
	let mc = null;

	lines = str.split("\n");
	for (let ln of lines) {
		while (ln_pos < ln.length) {
			for (let k in tokens.tokens) {
				tok = tokens.tokens[k];
				if (tok.nomatch) { continue; }
				match = tok_match(tok, ln, ln_pos);
				if (match) {
					l = new lexeme.Lexeme(k, match[0], ln_num, ln_pos);
					mc = tok_context(tok, ret.concat(l), l_index);
					if (mc != null) {
						ret.push(l);
						ln_pos += match[0].length;
						if (tok.transform) {
							tok.transform(ret, l_index, mc);
						}
						l_index++;
						break;
					} else {
						l = null;
					}
				}
			}
			if (!lexeme) { break; }
			l = null;
		}
		ln_pos = 0;
		ln_num++;
	}
	return ret;
}
