/*
*  A lexer implementation for the LibreSignage markup parser.
*  The token definitions are in lexer_defs.js.
*/

var lexeme = require('./lexeme.js');
var ldefs = require('./lexer_defs.js');
var lpost = require('./lexer_post.js');
var util = require('util');

function tok_match(tok, str, index) {
	return str.substring(index).match(tok.re);
}

function tok_context(tok, lexemes, index) {
	let ret = null;
	let mtype = '';
	let inv = false;

	if (!tok.context) { return -1; }
	for (let mcase in tok.context) {
		for (let i in tok.context[mcase]) {
			if (tok.context[mcase][i].charAt(0) != '!') {
				// Normal match.
				mtype = tok.context[mcase][i];
				inv = false;
			} else {
				// Inverted match.
				mtype = tok.context[mcase][i].substring(1);
				inv = true;
			}

			let tmp = index + parseInt(i, 10);
			if (tmp < 0 && inv) {
				// Match index OOB but matching inverted -> continue.
				ret = mcase;
				continue;
			} else if (tmp < 0) {
				// Match index OOB -> break.
				ret = null;
				break;
			}

			if ((lexemes[tmp].type == mtype) == inv) {
				ret = null;
				break;
			}
			ret = mcase;
		}
		if (ret) { return ret; }
	}
	return null;
}

module.exports.process = function(str) {
	let ret = [];
	let ln_pos = 0;
	let ln_num = 0;
	let l = null;
	let l_index = 0;
	let tok = null;
	let match = null;
	let mc = null;

	lines = str.split("\n");
	for (let ln of lines) {
		while (ln_pos < ln.length) {
			for (let k in ldefs.tokens) {
				tok = ldefs.tokens[k];
				if (tok.nomatch) { continue; }
				match = tok_match(tok, ln, ln_pos);
				if (match) {
					l = new lexeme.Lexeme(k, match[0], ln_num, ln_pos);
					mc = tok_context(tok, ret.concat(l), l_index);
					if (mc != null) {
						ret.push(l);
						ln_pos += match[0].length;
						l_index++;
						break;
					} else {
						l = null;
					}
				}
			}
			if (!l) { break; }
			l = null;
		}
		ln_pos = 0;
		ln_num++;
	}
	return lpost.lexer_post(ret);
}
