/*
*  LibreSignage JS Slide object definition with functions
*  for loading data through the LibreSignage API.
*/

var assert = require('ls-assert');

const SLIDE_LOCK_RENEWAL_HEADROOM = 30;

// Map animation identifiers to CSS classes.
const ANIMATION_MAP = {
	0: {
		hide: null,
		show: null,
	},
	1: {
		hide: 'swipe-left',
		show: 'swipe-from-right'
	},
	2: {
		hide: 'swipe-right',
		show: 'swipe-from-left'
	},
	3: {
		hide: 'swipe-up',
		show: 'swipe-from-below'
	},
	4: {
		hide: 'swipe-down',
		show: 'swipe-from-above'
	}
};

exports.Slide = class Slide {
	constructor(api) {
		assert.assert(api !== null);

		this.data = {};
		this.lock_ren_timeout_id = null;
		this.api = api;
	}

	load(id, lock, lock_renew, callback) {
		/*
		*  Load the slide with ID 'id'. If 'lock' is true, a
		*  lock is acquired on the slide before loading it.
		*  'lock_renew' is passed to Slide.lock_acquire().
		*  'callback' is called afterwards with the returned
		*  API error code as the first argument.
		*/

		// If this slide is locked, release the old lock first.
		if (this.data.id) { this.lock_release(null); }

		this.data.id = id
		if (lock) {
			this.lock_acquire(lock_renew, lock_err => {
				if (lock_err) {
					if (lock_err) { this.data = {}; }
					if (callback) { callback(lock_err); }
					return;
				}
				this.fetch(fetch_err => {
					if (fetch_err) { this.data = {}; }
					if (callback) { callback(fetch_err); }
				});
			})
		} else {
			this.fetch(err => {
				if (callback) { callback(err); }
			});
		}
	}

	fetch(callback) {
		/*
		*  Fetch the slide data for a slide. This function expects
		*  the 'id' value in this.data to be already set, ie. Slide.load()
		*  must be called first. 'callback' is called afterwards with
		*  the returned API error code as the first argument.
		*/
		assert.assert(this.has('id'));
		this.api.call(
			this.api.ENDP.SLIDE_GET,
			{ 'id': this.data.id },
			resp => {
				if (!resp.error) { this.set(resp.slide); }
				if (callback) { callback(resp.error); }
			}
		);
	}

	lock_release(callback) {
		/*
		*  Release the current lock on this slide and disable
		*  automatic lock renewal. 'callback' is called afterwards
		*  with the returned API error code as the first argument.
		*/
		assert.assert(this.has('id'));

		console.log(`Slide: Release lock '${this.data.id}'.`);
		clearTimeout(this.lock_ren_timeout_id);
		this.lock_ren_timeout_id = null;

		this.api.call(
			this.api.ENDP.SLIDE_LOCK_RELEASE,
			{ 'id': this.data.id },
			resp => { if (callback) { callback(resp.error); } }
		)
	}

	lock_acquire(renew, callback) {
		/*
		*  Attempt to acquire a lock on this slide. If 'renew' is
		*  true, automatic lock renewal is set up. 'callback' is
		*  called afterwards with the returned API error code as
		*  the first argument.
		*/
		assert.assert(this.has('id'));

		this.api.call(
			this.api.ENDP.SLIDE_LOCK_ACQUIRE,
			{ 'id': this.data.id },
			resp => {
				if (!resp.error && renew) {
					let ren_time = resp.expire
						- SLIDE_LOCK_RENEWAL_HEADROOM
						- Date.now()/1000;
					console.log(
						`Slide: Locked '${this.data.id}'. Renew in ` +
						`${ren_time} seconds.`
					);
					this.lock_ren_timeout_id = setTimeout(() => {
						this.lock_acquire(true, resp => {
							if (resp.error) {
								console.error(
									`Slide: Lock renewal` +
									`failed for '${this.data.id}'.`
								);
								this.lock_ren_timeout_id = null;
							} else {
								this.data.lock.expire = resp.expire;
							}
						});
					}, ren_time*1000);
				}
				if (callback) { callback(resp.error); }
			}
		);
	}

	is_locked_from_here() {
		return (
			this.data !== null
			&& this.data.lock !== null
			&& this.data.lock.session_id === this.api.CONFIG.session.id
			&& this.data.lock.expire >= Date.now()/1000
		);
	}

	save(callback) {
		/*
		*  Save this slide. 'callback' is called after this
		*  function has finished with the returned API error
		*  code as the first argument.
		*/
		this.api.call(
			this.api.ENDP.SLIDE_SAVE,
			this.data,
			resp => {
				if (!resp.error) {
					let tmp = {};
					for (let k of Object.keys(resp)) {
						if (k !== 'error') { tmp[k] = resp[k]; }
					}
					this.set(tmp);
				}
				if (callback) { callback(resp.error); }
			}
		);
	}

	remove(id, callback) {
		/*
		*  If 'id' is defined, remove the slide with the
		*  ID 'id' using the LibreSignage API. Otherwise
		*  remove the currently loaded slide. The function
		*  'callback' is called after the API call has
		*  completed. An API error code is passed to the
		*  callback function as the first argument.
		*/

		var r_id = "";
		if (id) {
			r_id = id;
		} else if (this.data.id) {
			r_id = this.data.id;
		} else {
			throw new Error("No slide ID specified for removal.");
		}

		this.api.call(
			this.api.ENDP.SLIDE_RM,
			{ 'id': r_id },
			resp => { if (callback) { callback(resp.error); } }
		);
	}

	dup(callback) {
		this.api.call(
			this.api.ENDP.SLIDE_DUP,
			{'id': this.get('id')},
			(resp) => {
				var s = null;
				if (!resp.error && callback) {
					s = new Slide(this.api);
					s.set(resp['slide']);
					callback(s);
				}
			}
		);
	}

	set(data) {
		Object.assign(this.data, data);
	}

	clear() { this.data = {}; }
	get(key) { return this.data[key]; }
	has(key) {
		return this.data !== null
			&& key in this.data
			&& this.data[key] !== null;
	}

	anim_hide() { return ANIMATION_MAP[this.get('animation')].hide; }
	anim_show() { return ANIMATION_MAP[this.get('animation')].show; }
}
