/*
*  LibreSignage JS Slide object definition with functions
*  for loading data through the LibreSignage API.
*/

const SLIDE_LOCK_RENEWAL_HEADROOM = 30;

exports.Slide = class Slide {
	constructor(api) {
		if (!api) {
			throw new Error(
				"Can't create a Slide without " +
				"a valid API object."
			);
		}

		// Map animation identifiers to CSS classes.
		this.ANIM_MAP = {
			0: {
				hide: null,
				show: null,
			},
			1: {
				hide: 'swipe-left',
				show: 'swipe-from-right'
			},
			2: {
				hide: 'swipe-right',
				show: 'swipe-from-left'
			},
			3: {
				hide: 'swipe-up',
				show: 'swipe-from-below'
			},
			4: {
				hide: 'swipe-down',
				show: 'swipe-from-above'
			}
		};
		this.data = {};
		this.lock_renewal = false;
		this.api = api;
	}

	load(id, lock, lock_renew, callback) {
		/*
		*  Load the slide with ID 'id' using the LibreSignage
		*  API. If 'lock' is true, a lock is acquired on the
		*  slide before loading it. 'lock_renew' is passed to
		*  Slide.lock_acquire(). The function 'callback' is
		*  called after the API call has completed. The received
		*  API error code is passed to the callback function as
		*  the first argument.
		*/
		let loader = () => {
			this.api.call(
				this.api.ENDP.SLIDE_GET,
				{ 'id': id },
				(resp) => {
					if (this.api.handle_disp_error(resp.error)) {
						if (callback) {
							callback(resp.error);
						}

						// Release the acquired lock.
						this.data.id = id;
						this.lock_release(() => {
							this.data.id = null;
						});
						return;
					}
					this.set(resp.slide);
					if (callback) {
						callback(resp.error);
					}
				}
			);
		}

		if (lock) {
			// Make Slide.lock_acquire() think a slide is already loaded.
			this.data.id = id

			this.lock_acquire(lock_renew, (resp) => {
				// Reset the ID. The loader() callback sets this.
				this.data.id = null;

				if (resp.error) {
					if (callback) { callback(resp.error); }
					return;
				}
				loader();
			})
		} else {
			loader();
		}
	}

	lock_release(callback) {
		/*
		*  Release the current lock on this slide and disable
		*  automatic lock renewal. 'callback' is called afterwards.
		*/
		if ('id' in this.data && this.data.id !== null) {
			console.log(
				`LibreSignage: Slide: Release lock '${this.data.id}'.`
			);
			this.lock_renewal = false;
			this.api.call(
				this.api.ENDP.SLIDE_LOCK_RELEASE,
				{ 'id': this.data.id },
				resp => { if (callback) { callback(resp.error); } }
			)
		}
	}

	lock_acquire(renew, callback) {
		/*
		*  Attempt to acquire a lock on this slide. If 'renew' is true,
		*  automatic lock renewal is enabled. After this function has
		*  finished, the function 'callback' is called with the returned
		*  data dictionary as the first argument.
		*/
		if (!('id' in this.data) || this.data.id === null) {
			throw new Error("Can't lock a slide with no ID.");
		}

		console.log(`LibreSignage: Slide: Lock '${this.data.id}'.`);
		this.api.call(
			this.api.ENDP.SLIDE_LOCK_ACQUIRE,
			{ 'id': this.data.id },
			resp => {
				if (resp.error) {
					if (callback) { callback(resp); }
					return;
				}

				if (renew) {
					this.lock_renewal = renew;
					let ren_time = resp.expire
						- SLIDE_LOCK_RENEWAL_HEADROOM
						- Date.now()/1000;
					console.log(
						`LibreSignage: Slide: Lock renewal ` +
						`in ${ren_time} seconds.`
					);
					setTimeout(() => {
						this.lock_acquire(this.lock_renewal, (resp) => {
							if (resp.error) {
								console.error(
									`LibreSignage: Slide: Lock renewal` +
									`failed for '${this.data.id}'.`
								);
								this.lock_renewal = false;
							}
						});
					}, ren_time*1000);
				}
				if (callback) { callback(resp); }
			}
		);
	}

	save(callback) {
		/*
		*  Save this slide. 'callback' is called after this
		*  function has finished with the returned API error
		*  code as the first argument.
		*/
		this.api.call(
			this.api.ENDP.SLIDE_SAVE,
			this.data,
			resp => {
				if (resp.error) {
					if (callback) { callback(resp.error); }
					return;
				}
				this.set(resp);
				if (callback) { callback(resp.error); }
			}
		);
	}

	remove(id, callback) {
		/*
		*  If 'id' is defined, remove the slide with the
		*  ID 'id' using the LibreSignage API. Otherwise
		*  remove the currently loaded slide. The function
		*  'callback' is called after the API call has
		*  completed. An API error code is passed to the
		*  callback function as the first argument.
		*/

		var r_id = "";
		if (id) {
			r_id = id;
		} else if (this.data.id) {
			r_id = this.data.id;
		} else {
			throw new Error("No slide ID specified for removal.");
		}

		this.api.call(this.api.ENDP.SLIDE_RM, { 'id': r_id }, (resp) => {
			if (resp.error) {
				console.error("LibreSignage: API error.");
				if (callback) { callback(resp.error); }
				return;
			}
			if (callback) { callback(resp.error); }
		});
	}

	dup(callback) {
		this.api.call(
			this.api.ENDP.SLIDE_DUP,
			{'id': this.get('id')},
			(resp) => {
				var s = null;
				if (this.api.handle_disp_error(resp['error'])) {
					return;
				}
				if (callback) {
					s = new Slide(this.api);
					s.set(resp['slide']);
					callback(s);
				}
			}
		);
	}

	set(data) {
		/*
		*  Copy 'data' to this slide's data array. Existing
		*  data is overwritten.
		*/
		Object.assign(this.data, data);
	}

	clear() { this.data = {}; }
	get(key) { return this.data[key]; }

	anim_hide() { return this.ANIM_MAP[this.get('animation')].hide; }
	anim_show() { return this.ANIM_MAP[this.get('animation')].show; }
}
