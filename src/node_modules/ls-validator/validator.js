/*
*  A universal input validator system for LibreSignage.
*/

var $ = require('jquery');

exports.BaseValidator = require('./basevalidator.js');
exports.NumValidator = require('./numvalidator.js');
exports.StrValidator = require('./strvalidator.js');
exports.EqValidator = require('./eqvalidator.js');
exports.WhitelistValidator = require('./whitelistvalidator.js');
exports.BlacklistValidator = require('./blacklistvalidator.js');
exports.FileSelectorValidator = require('./fileselectorvalidator.js');

exports.ValidatorSelector = class ValidatorSelector {
	/*
	*  A class used for selecting the inputs to
	*  validate with validator objects.
	*/
	constructor(query, style, validators, callbacks) {
		/*
		*  Construct the ValidatorSelector object.
		*
		*  * 'query' is a jQuery object or a query string that
		*    selects the input elements to validate.
		*  * 'style' is a jQuery object or a query string that
		*    selects the elements to apply the styling onto. If you
		*    want to display a feedback message to the user on invalid
		*    input you should create a container element for the input
		*    and add an element (eg. a DIV) with the class
		*    'invalid-feedback' along with the actual input element.
		*    This container is the element you should pass in 'style'.
		*    This class then takes care of showing the feedback messages
		*    and applying the needed styling if the input is invalid.
		*    The feedback messages themselves are passed in the actual
		*    Validator constructor calls in the 'msg' parameter. If
		*    style == null, no styling is applied to any HTML elements.
		*  * 'validators' is a list of validator objects to add
		*    to the selector. 'validators' can be left null if
		*    it isn't needed. Validators can also be added with
		*    ValidatorSelector.add().
		*  * 'callbacks' is an array of callback functions to
		*    call every time the validation state changes. The
		*    ValidatorSelector object is passed as the first
		*    argument to the callback functions.
		*/
		this.validators = [];
		this.callbacks = [];
		this.enabled = true;
		this.valid = null; // validate() sets this.
		this.query = $(query);

		if (style) {
			this.style = $(style);
		} else {
			this.style = null;
		}

		if (!this.query.length) {
			throw new Error('No input elements selected.');
		}
		this.query.on('input', () => { this.validate(); });

		if (validators) {
			for (let v of validators) {
				this.add(v);
			}
		}
		if (callbacks) {
			for (let c of callbacks) {
				this.add_callback(c);
			}
		}
		this.validate();
	}

	add(validator) {
		// Add a validator to the ValidatorSelector object.
		if (!validator || validator != Object(validator)) {
			throw new Error('Invalid validator object.');
		}
		this.validators.push(validator);
	}

	add_callback(callback) {
		// Add a callback to the ValidatorSelector object.
		if (!callback) { return; }
		this.callbacks.push(callback);
	}

	set_dom_msg(msg) {
		if (this.style && msg) {
			this.msg = msg;
			this.style.find('.invalid-feedback').html(msg);
		}
	}

	set_state(valid) {
		if (this.valid != valid) {
			this.valid = valid;
			for (let c of this.callbacks) { c(this); }
		}
	}

	set_style(valid) {
		if (this.style) {
			if (!valid) {
				this.query.addClass('is-invalid');
			} else if (valid) {
				this.query.removeClass('is-invalid');
			}
		}
	}

	get_state() { return this.valid; }

	disable() {
		this.enabled = false;
		this.validate();
	}

	enable () {
		this.enabled = true;
		this.validate();
	}

	validate() {
		if (this.enabled) {
			for (let v of this.validators) {
				if (!v.validate(this)) {
					this.set_state(false);
					if (!v.nostyle) {
						this.set_style(false);
						this.set_dom_msg(v.get_msg());
					} else {
						this.set_style(true);
						this.set_dom_msg('');
					}
					return;
				}
			}
		}

		this.set_state(true);
		this.set_style(true);
		this.set_dom_msg('');
	}
}

exports.ValidatorTrigger = class ValidatorTrigger {
	/*
	*  This class is used to group together ValidatorSelector
	*  objects so that a callback function can be called when
	*  any of the ValidatorSelectors chages state.
	*/
	constructor(selectors, callback) {
		/*
		*  Construct the ValidatorTrigger object.
		*
		*  * 'selectors' is an array of selectors to use for
		*    this trigger.
		*  * 'callback' is the callback function to call when
		*    a change occurs.
		*
		*  Note that you need to call ValidatorTrigger.trigger()
		*  after calling this constructor to make sure the initial
		*  state of the ValidatorSelectors is taken into account.
		*/
		this.callback = callback;
		this.selectors = selectors;
		for (let s of this.selectors) {
			s.add_callback((sel) => { this.trigger(); });
		}
	}

	trigger() {
		/*
		*  Check the validation state of the ValidatorSelectors
		*  and call the callback function if needed.
		*/
		let tmp = true;
		for (let s of this.selectors) {
			tmp = tmp && s.get_state();
			if (!tmp) { break; }
		}
		this.valid = tmp;
		if (this.callback) { this.callback(this.valid); }
	}

	is_valid() { return this.valid; }
}






