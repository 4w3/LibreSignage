/*
*  A universal input validator system for LibreSignage.
*/

var $ = require('jquery');

exports.ValidatorSelector = class ValidatorSelector {
	/*
	*  A class used for selecting the inputs to
	*  validate with validator objects.
	*/
	constructor(query, style, validators, callbacks) {
		/*
		*  Construct the ValidatorSelector object.
		*
		*  * 'query' is a jQuery object or a query string that
		*    selects the input elements to validate.
		*  * 'style' is a jQuery object or a query string that
		*    selects the elements to apply the styling onto. If you
		*    want to display a feedback message to the user on invalid
		*    input you should create a container element for the input
		*    and add an element (eg. a DIV) with the class
		*    'invalid-feedback' along with the actual input element.
		*    This container is the element you should pass in 'style'.
		*    This class then takes care of showing the feedback messages
		*    and applying the needed styling if the input is invalid.
		*    The feedback messages themselves are passed in the actual
		*    Validator constructor calls in the 'msg' parameter. If
		*    style == null, no styling is applied to any HTML elements.
		*  * 'validators' is a list of validator objects to add
		*    to the selector. 'validators' can be left null if
		*    it isn't needed. Validators can also be added with
		*    ValidatorSelector.add().
		*  * 'callbacks' is an array of callback functions to
		*    call every time the validation state changes. The
		*    ValidatorSelector object is passed as the first
		*    argument to the callback functions.
		*/
		this.validators = [];
		this.callbacks = [];
		this.enabled = true;
		this.valid = null; // validate() sets this.
		this.query = $(query);

		if (style) {
			this.style = $(style);
		} else {
			this.style = null;
		}

		if (!this.query.length) {
			throw new Error('No input elements selected.');
		}
		this.query.on('input', () => { this.validate(); });

		if (validators) {
			for (let v of validators) {
				this.add(v);
			}
		}
		if (callbacks) {
			for (let c of callbacks) {
				this.add_callback(c);
			}
		}
		this.validate();
	}

	add(validator) {
		// Add a validator to the ValidatorSelector object.
		if (!validator || validator != Object(validator)) {
			throw new Error('Invalid validator object.');
		}
		this.validators.push(validator);
	}

	add_callback(callback) {
		// Add a callback to the ValidatorSelector object.
		if (!callback) { return; }
		this.callbacks.push(callback);
	}

	set_dom_msg(msg) {
		if (this.style && msg) {
			this.msg = msg;
			this.style.find('.invalid-feedback').html(msg);
		}
	}

	set_state(valid) {
		if (this.valid != valid) {
			this.valid = valid;
			for (let c of this.callbacks) { c(this); }
		}
	}

	set_style(valid) {
		if (this.style) {
			if (!valid) {
				this.query.addClass('is-invalid');
			} else if (valid) {
				this.query.removeClass('is-invalid');
			}
		}
	}

	get_state() { return this.valid; }

	disable() {
		this.enabled = false;
		this.validate();
	}

	enable () {
		this.enabled = true;
		this.validate();
	}

	validate() {
		if (this.enabled) {
			for (let v of this.validators) {
				if (!v.validate(this)) {
					this.set_state(false);
					if (!v.nostyle) {
						this.set_style(false);
						this.set_dom_msg(v.get_msg());
					}
					return;
				}
			}
		}

		this.set_state(true);
		this.set_style(true);
		this.set_dom_msg('');
	}
}

exports.ValidatorTrigger = class ValidatorTrigger {
	/*
	*  This class is used to group together ValidatorSelector
	*  objects so that a callback function can be called when
	*  any of the ValidatorSelectors chages state.
	*/
	constructor(selectors, callback) {
		/*
		*  Construct the ValidatorTrigger object.
		*
		*  * 'selectors' is an array of selectors to use for
		*    this trigger.
		*  * 'callback' is the callback function to call when
		*    a change occurs.
		*
		*  Note that you need to call ValidatorTrigger.trigger()
		*  after calling this constructor to make sure the initial
		*  state of the ValidatorSelectors is taken into account.
		*/
		this.callback = callback;
		this.selectors = selectors;
		for (let s of this.selectors) {
			s.add_callback((sel) => { this.trigger(); });
		}
	}

	trigger() {
		/*
		*  Check the validation state of the ValidatorSelectors
		*  and call the callback function if needed.
		*/
		let tmp = true;
		for (let s of this.selectors) {
			tmp = tmp && s.get_state();
			if (!tmp) { break; }
		}
		this.valid = tmp;
		if (this.callback) { this.callback(this.valid); }
	}

	is_valid() { return this.valid; }
}

exports.Validator = class Validator {
	constructor(settings, msg, nostyle) {
		/*
		*  Construct the Validator object. Classes
		*  extending this class should always call the
		*  original constructor with eg. 'super(...args);'
		*  if they redefine the constructor. See the
		*  predefined validators for examples.
		*/
		if (settings && settings != Object(settings)) {
			throw new Error('Invalid validator settings.');
		}
		this.settings = settings;
		this.msg = msg;
		this.nostyle = nostyle;
	}

	get_msg() {
		return this.msg;
	}

	chk_settings(proto) {
		/*
		*  Check the current this.settings associative array
		*  against the 'proto' array. If settings that exist
		*  in 'proto' are missing from this.settings, errors
		*  are thrown.
		*/
		for (var i in proto) {
			var keys = Object.keys(this.settings);
			if (keys.indexOf(proto[i]) == -1) {
				throw new Error(
					'Invalid Validator settings. ("' +
					proto[i] + '" missing).'
				);
			}
		}
	}
}

exports.NumValidator = class NumValidator extends exports.Validator {
	/*
	*  Validate numeric inputs.
	*
	*  Settings:
	*    * min = The minimum value.    (number)
	*    * max = The maximum value.    (number)
	*    * nan = Allow NaN values.     (boolean)
	*    * float = Allow float values. (boolean)
	*/
	constructor(...args) {
		super(...args);
		this.chk_settings(['min', 'max', 'nan']);
	}

	validate(selector) {
		var val = null;
		var min = this.settings.min;
		var max = this.settings.max;
		var nan = this.settings.nan;
		var float = this.settings.float;
		var a, b;
		var ret = true;
		selector.query.each(function() {
			if (float) {
				val = parseFloat($(this).val());
			} else {
				if ($(this).val().indexOf('.') != -1) {
					ret = false;
					return false;
				}
				val = parseInt($(this).val(), 10);
			}
			if (isNaN(val) && !nan) {
				ret = false;
				return false;
			} else if (isNaN(val) && nan) {
				ret = true;
				return false;
			}
			a = (min == null || val >= min);
			b = (max == null || val <= max);
			ret = a && b;
		});
		return ret;
	}
}

exports.StrValidator = class StrValidator extends exports.Validator {
	/*
	*  Validate string inputs.
	*
	*  Settings:
	*    * min = The minimum length.    (integer)
	*    * max = The maximum length.    (integer)
	*    * regex = A "whitelist" regex. (regex)
	*/
	constructor(...args) {
		super(...args);
		this.chk_settings(['min', 'max', 'regex']);
	}

	validate(selector) {
		var val = null;
		var min = this.settings.min;
		var max = this.settings.max;
		var regex = this.settings.regex;
		var a, b, c;
		var ret = true;
		var tmp = null;

		selector.query.each(function() {
			val = $(this).val();
			a = (min == null || val.length >= min);
			b = (max == null || val.length <= max);
			if (regex == null) {
				c = true;
			} else {
				tmp = val.match(regex);
				c = (tmp && tmp[0].length == val.length);
			}
			ret = a && b && c;
			if (!ret) { return false; }
		});
		return ret;
	}
}

exports.EqValidator = class EqValidator extends exports.Validator {
	/*
	*  Validate all the selected inputs to have the same value.
	*  This validator doesn't need any settings.
	*/
	validate(selector) {
		var ret = true;
		var v = null;
		selector.query.each(function() {
			if (v == null) {
				v = $(this).val();
			} else if (v != $(this).val()) {
				ret = false;
				return false;
			}
		});
		return ret;
	}
}

exports.WhitelistValidator = class WhitelistValidator
									extends exports.Validator {
	/*
	*  Validate against a set of allowed values.
	*
	*  Settings:
	*    * wl = The whitelist to use.  (array)
	*/
	constructor(...args) {
		super(...args);
		this.chk_settings(['wl']);
	}

	validate(selector) {
		var ret = true;
		var wl = this.settings.wl;
		selector.query.each(function() {
			if (!wl.includes($(this).val())) {
				ret = false;
				return false;
			}
		});
		return ret;
	}
}

exports.BlacklistValidator = class BlacklistValidator
									extends exports.Validator {
	/*
	*  Validate against a set of disallowed values.
	*
	*  Settings:
	*    * bl = The blacklist to use.  (array)
	*/
	constructor(...args) {
		super(...args);
		this.chk_settings(['bl']);
	}

	validate(selector) {
		var ret = true;
		var bl = this.settings.bl;
		selector.query.each(function() {
			if (bl.includes($(this).val())) {
				ret = false;
				return false;
			}
		});
		return ret;
	}
}

exports.FileSelectorValidator = class FileSelectorValidator
								extends exports.Validator {
	/*
	*  Validate a file selector input.
	*
	*  Settings:
	*    * mimes     = An array of accepted file MIME types.
	*    * name_len  = The maximum allowed filename length.
	*    * regex     = A "whitelist" regex for filenames.
	*    * minfiles  = Minimum number of selected files.
	*    * bl        = A blacklist of files to disallow.
	*                  This can be a getter function or an
	*                  array.
	*/
	constructor(...args) {
		super(...args);
		this.chk_settings(
			['mimes', 'name_len', 'regex', 'minfiles', 'bl']
		);
	}

	validate(selector) {
		let ret = true;
		var mimes = this.settings.mimes;
		var name_len = this.settings.name_len;
		var regex = this.settings.regex;
		var minfiles = this.settings.minfiles;

		var bl = null;
		if (typeof this.settings.bl === 'function') {
			bl = this.settings.bl();
		} else {
			bl = this.settings.bl;
		}

		selector.query.each(function() {
			if (minfiles != null && this.files.length < minfiles) {
				ret = false;
				return false;
			}

			for (let i = 0; i < this.files.length; i++) {
				if (
					(
						name_len != null
						&& this.files.item(i).name.length > name_len
					) || (
						mimes != null
						&& !mimes.includes(this.files.item(i).type)
					) || (
						regex != null
						&& !this.files.item(i).name.match(regex)
					) || (
						bl != null
						&& bl.length != 0
						&& bl.includes(this.files.item(i).name)
					)
				) {
					ret = false;
					return false;
				}
			}
		});
		return ret;
	}
}
